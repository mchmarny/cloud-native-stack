#!/usr/bin/env bash

set -euo pipefail

# input variables
INSTALL_DIR="${1:-/usr/local/bin}"

# global variables
OWNER="mchmarny"  # NVIDIA
PROJECT="cloud-native-stack"
REPO="$OWNER/$PROJECT"
BIN_NAME="eidos"
REQUIRED_TOOLS=(curl)
COLOR_RED='\033[0;31m'
COLOR_RESET='\033[0m' # No color

# global functions
usage() {
  cat <<EOF
Install utility for $BIN_NAME

Usage: $0 [-d install_dir]
EOF
  exit 1
}

err() {
  local message=$1
  printf "${COLOR_RED}$message${COLOR_RESET}\n" >&2
  exit 1
}

msg() {
  local message=$1
  printf "$message\n" >&2
}

has_tools() {
  local tools=("$@")
  for tool in "${tools[@]}"; do
      if ! command -v $tool &> /dev/null
      then
          err "Required tool ($tool) is not installed."
      fi
  done
}

full_path() {
    local rel_path="$1"
    if [[ ! -f $rel_path ]]; then
      err "Config file not found: $rel_path"
    fi
    
    if command -v realpath &> /dev/null; then
        realpath "$rel_path"
    elif command -v readlink &> /dev/null; then
        readlink -f "$rel_path"
    else
        echo "Neither realpath nor readlink is available on this system."
        return 1
    fi
}

getOS() {
    local os
    case $(uname -s) in
        Darwin)
            os="darwin"
            ;;
        Linux)
            os="linux"
            ;;
        *)
            os="windows"
            ;;
    esac
    echo $os
}

getBinaryName() {
    local bin_name="$1"
    local version="$2"
    local os="$3"
    local arch="$4"
    echo "${bin_name}_${version}_${os}_${arch}"
}

# Parse the input arguments
while getopts "d:" opt; do
  case $opt in
    d)
      INSTALL_DIR=$OPTARG
      ;;
    \?)
      usage
      ;;
  esac
done

# derived variables
OS=$(getOS)
ARCH=$(uname -m)
GITHUB_API="https://api.github.com"
RELEASES_URL="${GITHUB_API}/repos/${REPO}/releases/latest"

# HACK: If $ARCH == "x86_64" replace it with "amd64"
if [[ $ARCH == "x86_64" ]]; then
    ARCH="amd64"
fi

# Validate
has_tools "${REQUIRED_TOOLS[@]}"
[[ $OS != "linux" && $OS != "darwin" ]] && err "Unsupported OS: $OS"
[[ $ARCH != "amd64" && $ARCH != "arm64" ]] && err "Unsupported architecture: $ARCH"

# Get the latest release version from GitHub
msg "Fetching latest release from GitHub..."
RELEASE_JSON=$(curl -s "$RELEASES_URL")
if [[ -z "$RELEASE_JSON" ]]; then
    err "Failed to fetch release information from GitHub API"
fi
VERSION=$(echo "$RELEASE_JSON" | grep -m 1 '"tag_name"' | sed -E 's/.*"tag_name"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/')
if [[ -z $VERSION || $VERSION == "null" ]]; then
    err "Failed to extract version from GitHub API response"
fi

# parse the binary name
FULL_BIN_NAME=$(getBinaryName $BIN_NAME $VERSION $OS $ARCH)

msg "OS: $OS"
msg "ARCH: $ARCH"
msg "VERSION: $VERSION"

# Download the binary from GitHub releases
msg "Downloading $FULL_BIN_NAME"
TEMP_BIN_DIR=$(mktemp -d)
ASSET_URL="https://github.com/${REPO}/releases/download/${VERSION}/${FULL_BIN_NAME}"
HTTP_CODE=$(curl -w "%{http_code}" -Lo "${TEMP_BIN_DIR}/${FULL_BIN_NAME}" "$ASSET_URL")
if [[ $HTTP_CODE != "200" ]]; then
    err "Failed to download binary (HTTP $HTTP_CODE). Asset may not exist: $ASSET_URL"
fi

# Validate the binary
msg "Validating the binary"
chmod +x "${TEMP_BIN_DIR}/${FULL_BIN_NAME}"
CHECKSUM_URL="https://github.com/${REPO}/releases/download/${VERSION}/eidos_checksums.txt"
msg "Downloading checksums: $CHECKSUM_URL"
HTTP_CODE=$(curl -w "%{http_code}" -Lo ${TEMP_BIN_DIR}/checksums.txt $CHECKSUM_URL)
if [[ $HTTP_CODE != "200" ]]; then
    err "Failed to download checksums (HTTP $HTTP_CODE). File may not exist: $CHECKSUM_URL"
fi
(cd $TEMP_BIN_DIR && cat ${TEMP_BIN_DIR}/checksums.txt | grep $FULL_BIN_NAME | shasum -a 256 --check --strict)

# Install the binary
msg "Installing $BIN_NAME to $INSTALL_DIR"
msg "Use -d flag to change the installation directory"
sudo mv "${TEMP_BIN_DIR}/${FULL_BIN_NAME}" "${INSTALL_DIR}/${BIN_NAME}"

msg "$BIN_NAME installed to ${INSTALL_DIR}/${BIN_NAME}"
${BIN_NAME} --version
msg "Done, enjoy!"
