package bundle

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"time"
)

// BundleResult contains the result of a single bundler execution.
type Result struct {
	// Type is the bundler type that generated this result.
	Type Type `json:"type" yaml:"type"`

	// Files is the list of files generated by this bundler.
	Files []string `json:"files" yaml:"files"`

	// Duration is the time taken to generate the bundle.
	Duration time.Duration `json:"duration" yaml:"duration"`

	// Size is the total size in bytes of all generated files.
	Size int64 `json:"size_bytes" yaml:"size_bytes"`

	// Checksum is the SHA256 checksum of the bundle contents.
	Checksum string `json:"checksum" yaml:"checksum"`

	// Errors contains non-fatal errors encountered during generation.
	Errors []string `json:"errors,omitempty" yaml:"errors,omitempty"`

	// Success indicates whether the bundler completed successfully.
	Success bool `json:"success" yaml:"success"`
}

// Output contains the aggregated results of all bundler executions.
type Output struct {
	// Results contains individual bundler results.
	Results []*Result `json:"results" yaml:"results"`

	// TotalSize is the total size in bytes of all generated files.
	TotalSize int64 `json:"total_size_bytes" yaml:"total_size_bytes"`

	// TotalFiles is the total count of generated files.
	TotalFiles int `json:"total_files" yaml:"total_files"`

	// TotalDuration is the total time taken for all bundlers.
	TotalDuration time.Duration `json:"total_duration" yaml:"total_duration"`

	// Errors contains errors from failed bundlers.
	Errors []BundleError `json:"errors,omitempty" yaml:"errors,omitempty"`

	// OutputDir is the directory where bundles were generated.
	OutputDir string `json:"output_dir" yaml:"output_dir"`
}

// BundleError represents an error from a specific bundler.
type BundleError struct {
	BundlerType Type   `json:"bundler_type" yaml:"bundler_type"`
	Error       string `json:"error" yaml:"error"`
}

// HasErrors returns true if any bundler failed.
func (o *Output) HasErrors() bool {
	return len(o.Errors) > 0
}

// SuccessCount returns the number of successful bundlers.
func (o *Output) SuccessCount() int {
	count := 0
	for _, r := range o.Results {
		if r.Success {
			count++
		}
	}
	return count
}

// FailureCount returns the number of failed bundlers.
func (o *Output) FailureCount() int {
	return len(o.Results) - o.SuccessCount()
}

// Summary returns a human-readable summary of the bundle generation.
func (o *Output) Summary() string {
	return fmt.Sprintf(
		"Generated %d files (%s) in %v. Success: %d/%d bundlers.",
		o.TotalFiles,
		formatBytes(o.TotalSize),
		o.TotalDuration.Round(time.Millisecond),
		o.SuccessCount(),
		len(o.Results),
	)
}

// formatBytes formats bytes into human-readable format.
func formatBytes(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}

// ComputeChecksum computes SHA256 checksum of file contents.
func ComputeChecksum(contents []byte) string {
	hash := sha256.Sum256(contents)
	return hex.EncodeToString(hash[:])
}

// NewBundleResult creates a new BundleResult with the given type.
func NewResult(bundlerType Type) *Result {
	return &Result{
		Type:    bundlerType,
		Files:   make([]string, 0),
		Errors:  make([]string, 0),
		Success: false,
	}
}

// AddFile adds a file to the result and updates size.
func (r *Result) AddFile(path string, size int64) {
	r.Files = append(r.Files, path)
	r.Size += size
}

// AddError adds a non-fatal error to the result.
func (r *Result) AddError(err error) {
	if err != nil {
		r.Errors = append(r.Errors, err.Error())
	}
}

// MarkSuccess marks the bundle generation as successful.
func (r *Result) MarkSuccess() {
	r.Success = true
}

// ByType returns results grouped by bundler type.
// This allows easy lookup of results for specific bundlers.
func (o *Output) ByType() map[Type]*Result {
	results := make(map[Type]*Result, len(o.Results))
	for _, r := range o.Results {
		results[r.Type] = r
	}
	return results
}

// FailedBundlers returns list of bundler types that failed.
// This provides a quick way to identify which bundlers encountered errors.
func (o *Output) FailedBundlers() []Type {
	failed := make([]Type, 0, len(o.Errors))
	for _, e := range o.Errors {
		failed = append(failed, e.BundlerType)
	}
	return failed
}

// SuccessfulBundlers returns list of bundler types that succeeded.
// This complements FailedBundlers for complete status overview.
func (o *Output) SuccessfulBundlers() []Type {
	successful := make([]Type, 0, len(o.Results))
	for _, r := range o.Results {
		if r.Success {
			successful = append(successful, r.Type)
		}
	}
	return successful
}
