package prometheus

import (
	"context"
	"os"
	"testing"

	"github.com/NVIDIA/cloud-native-stack/pkg/bundler/config"
	"github.com/NVIDIA/cloud-native-stack/pkg/bundler/types"
	"github.com/NVIDIA/cloud-native-stack/pkg/recipe"
	"github.com/stretchr/testify/require"

)

func TestNewBundler(t *testing.T) {
	tests := []struct {
		name   string
		config *config.Config
	}{
		{
			name:   "nil config",
			config: nil,
		},
		{
			name:   "valid config",
			config: &config.Config{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			bundler := NewBundler(tt.config)
			require.NotNil(t, bundler)
			require.NotNil(t, bundler.BaseBundler)
		})
	}
}

func TestBundler_Make(t *testing.T) {
	tests := []struct {
		name           string
		input          recipe.RecipeInput
		expectError    bool
		expectFiles    []string
		expectContent  map[string]string
	}{
		{
			name: "valid prometheus component",
			input: &recipe.RecipeResult{
				ComponentRefs: []recipe.ComponentRef{
					{
						Name:        "prometheus",
						Type:        "Helm",
						Source:      "https://prometheus-community.github.io/helm-charts",
						Version:     "25.29.0",
						ValuesFile:  "components/prometheus/values.yaml",
					},
				},
			},
			expectFiles: []string{
				"values.yaml",
				"checksums.txt",
			},
			expectContent: map[string]string{
				"values.yaml": "# Generated by NVIDIA Cloud Native Stack",
			},
		},
		{
			name: "missing prometheus component",
			input: &recipe.RecipeResult{
				ComponentRefs: []recipe.ComponentRef{
					{
						Name: "other-component",
						Type: "Helm",
					},
				},
			},
			expectFiles: []string{
				"values.yaml",
				"checksums.txt",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			bundler := NewBundler(&config.Config{})
			tempDir := t.TempDir()

			result, err := bundler.Make(context.Background(), tt.input, tempDir)

			if tt.expectError {
				require.Error(t, err)
				return
			}

			require.NoError(t, err)
			require.NotNil(t, result)
			require.Equal(t, types.BundleTypePrometheus, result.Type)

			// Check expected files exist
			for _, expectedFile := range tt.expectFiles {
				filePath := tempDir + "/" + expectedFile
				_, err := os.Stat(filePath)
				require.NoError(t, err, "expected file %s to exist", expectedFile)
			}

			// Check file contents
			for file, expectedContent := range tt.expectContent {
				filePath := tempDir + "/" + file
				content, err := os.ReadFile(filePath)
				require.NoError(t, err)
				require.Contains(t, string(content), expectedContent)
			}
		})
	}
}

func TestComponentConfig(t *testing.T) {
	require.Equal(t, Name, componentConfig.Name)
	require.Equal(t, "prometheus", componentConfig.DisplayName)
	require.Equal(t, []string{"prometheus"}, componentConfig.ValueOverrideKeys)
	require.Equal(t, "https://prometheus-community.github.io/helm-charts", componentConfig.DefaultHelmRepository)
	require.Equal(t, "prometheus-community/prometheus", componentConfig.DefaultHelmChart)
	require.Equal(t, "25.29.0", componentConfig.DefaultHelmChartVersion)

	// Check system node selector paths
	expectedSystemNodeSelectorPaths := []string{
		"server.nodeSelector",
		"alertmanager.nodeSelector",
		"pushgateway.nodeSelector",
	}
	require.Equal(t, expectedSystemNodeSelectorPaths, componentConfig.SystemNodeSelectorPaths)

	// Check system toleration paths
	expectedSystemTolerationPaths := []string{
		"server.tolerations",
		"alertmanager.tolerations",
		"pushgateway.tolerations",
	}
	require.Equal(t, expectedSystemTolerationPaths, componentConfig.SystemTolerationPaths)

	// Check accelerated node selector paths
	expectedAcceleratedNodeSelectorPaths := []string{
		"nodeExporter.nodeSelector",
	}
	require.Equal(t, expectedAcceleratedNodeSelectorPaths, componentConfig.AcceleratedNodeSelectorPaths)

	// Check accelerated toleration paths
	expectedAcceleratedTolerationPaths := []string{
		"nodeExporter.tolerations",
	}
	require.Equal(t, expectedAcceleratedTolerationPaths, componentConfig.AcceleratedTolerationPaths)
}