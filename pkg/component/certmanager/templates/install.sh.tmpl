#!/usr/bin/env bash
# cert-manager Installation Script
# Generated from Cloud Native Stack Recipe
# Timestamp: {{ .Timestamp }}
# Bundler Version: {{ .Version }}
# Recipe Version: {{ .RecipeVersion }}

set -euo pipefail

# Configuration
NAMESPACE="{{ .Namespace }}"
HELM_REPO="{{ .HelmRepository }}"
HELM_CHART="{{ .HelmChart }}"
{{- if .HelmChartVersion }}
CHART_VERSION="{{ .HelmChartVersion }}"
{{- end }}

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

check_prerequisites() {
    log_info "Checking prerequisites..."
    
    if ! command -v kubectl &> /dev/null; then
        log_error "kubectl not found. Please install kubectl."
        exit 1
    fi
    
    if ! command -v helm &> /dev/null; then
        log_error "helm not found. Please install Helm 3."
        exit 1
    fi
    
    if ! kubectl cluster-info &> /dev/null; then
        log_error "Cannot connect to Kubernetes cluster."
        exit 1
    fi
    
    log_info "Prerequisites check passed."
}

add_helm_repo() {
    log_info "Adding Helm repository..."
    helm repo add jetstack ${HELM_REPO} --force-update
    helm repo update
    log_info "Helm repository added successfully."
}

create_namespace() {
    if kubectl get namespace ${NAMESPACE} &> /dev/null; then
        log_info "Namespace ${NAMESPACE} already exists."
    else
        log_info "Creating namespace ${NAMESPACE}..."
        kubectl create namespace ${NAMESPACE}
        log_info "Namespace created successfully."
    fi
}

install_cert_manager() {
    log_info "Installing cert-manager..."
    
    helm upgrade --install cert-manager ${HELM_CHART} \
        --namespace ${NAMESPACE} \
        --create-namespace \
        {{- if .HelmChartVersion }}
        --version ${CHART_VERSION} \
        {{- end }}
        {{- if .InstallCRDs }}
        --set installCRDs=true \
        {{- end }}
        --values values.yaml \
        --wait \
        --timeout 10m
    
    log_info "cert-manager installed successfully."
}

verify_installation() {
    log_info "Verifying cert-manager installation..."
    
    # Wait for all pods to be ready
    kubectl wait --for=condition=ready pod \
        -l app.kubernetes.io/instance=cert-manager \
        -n ${NAMESPACE} \
        --timeout=300s
    
    # Check CRDs
    log_info "Checking CRDs..."
    kubectl get crd | grep cert-manager || {
        log_error "cert-manager CRDs not found"
        exit 1
    }
    
    # Check pods
    log_info "Checking pods..."
    kubectl get pods -n ${NAMESPACE}
    
    log_info "Installation verified successfully."
}

print_next_steps() {
    cat << EOF

${GREEN}cert-manager has been successfully installed!${NC}

Next steps:
1. Create an Issuer or ClusterIssuer:
   kubectl apply -f - <<YAML
   apiVersion: cert-manager.io/v1
   kind: ClusterIssuer
   metadata:
     name: letsencrypt-prod
   spec:
     acme:
       server: https://acme-v02.api.letsencrypt.org/directory
       email: your-email@example.com
       privateKeySecretRef:
         name: letsencrypt-prod
       solvers:
       - http01:
           ingress:
             class: nginx
   YAML

2. Request a certificate:
   kubectl apply -f - <<YAML
   apiVersion: cert-manager.io/v1
   kind: Certificate
   metadata:
     name: example-com
     namespace: default
   spec:
     secretName: example-com-tls
     issuerRef:
       name: letsencrypt-prod
       kind: ClusterIssuer
     dnsNames:
     - example.com
     - www.example.com
   YAML

3. Verify certificate status:
   kubectl get certificate -A
   kubectl describe certificate example-com -n default

Documentation: https://cert-manager.io/docs/

EOF
}

main() {
    log_info "Starting cert-manager installation..."
    
    check_prerequisites
    add_helm_repo
    create_namespace
    install_cert_manager
    verify_installation
    print_next_steps
    
    log_info "cert-manager installation complete!"
}

main "$@"
