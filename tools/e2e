#!/bin/bash
set -eo pipefail

# =============================================================================
# E2E Integration Tests for cnsctl CLI
# =============================================================================
#
# PURPOSE:
# This script tests the compiled cnsctl binary and CLI flag handling.
# It complements Go unit tests by testing what can only be verified after
# the binary is built: CLI argument parsing, flag combinations, and
# end-to-end command execution.
#
# WHAT THIS SCRIPT TESTS:
# - Binary builds successfully (make build)
# - CLI workflow: cnsctl recipe → cnsctl bundle
# - CLI flags: --set, --system-node-selector, --accelerated-node-toleration, etc.
# - Flag combinations and interactions
#
# WHAT GO TESTS COVER (not duplicated here):
# - YAML file validation: pkg/recipe/yaml_test.go
#   (parsing, references, enums, constraints, inheritance chains)
# - Metadata behavior: pkg/recipe/metadata_test.go
#   (Merge, TopologicalSort, ValidateDependencies, inheritance resolution)
# - Recipe validation: pkg/recipe/recipe_test.go
#   (Validate, ValidateStructure, ValidateMeasurementExists)
#
# DESIGN PRINCIPLE:
# Front-load validation into Go tests (run during development with 'go test')
# so issues are caught early. Reserve this script for true integration testing
# that requires the compiled binary.
#
# =============================================================================

# Dir setup
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
. "${DIR}/common"
ROOT=$(dirname "${DIR}")

# Check required tools
has_tools awk find grep make sed uname

# Default values
OUTPUT_DIR=""
CNSCTL_BIN=""

# Test configuration
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

# Parse flags
usage() {
  echo "Usage: $0 [OPTIONS]"
  echo ""
  echo "Options:"
  echo "  -o, --output PATH     Output directory for test artifacts (default: temp dir)"
  echo "  -h, --help            Show this help message"
  echo ""
  echo "E2E Integration Tests for cnsctl CLI"
  echo ""
  echo "This script tests what requires a compiled binary:"
  echo "  1. Binary builds successfully (make build)"
  echo "  2. CLI workflow: cnsctl recipe → cnsctl bundle (for each leaf recipe)"
  echo "  3. CLI flag handling:"
  echo "     - --system-node-selector, --accelerated-node-selector"
  echo "     - --system-node-toleration, --accelerated-node-toleration"
  echo "     - --set (value overrides)"
  echo "     - Combined flag interactions"
  echo ""
  echo "Go tests cover (not duplicated here):"
  echo "  - pkg/recipe/yaml_test.go: YAML parsing, references, enums, constraints"
  echo "  - pkg/recipe/metadata_test.go: Merge, inheritance chains, topological sort"
  echo "  - pkg/recipe/recipe_test.go: Recipe validation methods"
  echo ""
  echo "Run 'go test ./pkg/recipe/...' to validate recipe data during development."
  echo ""
  echo "Examples:"
  echo "  $0                        # Run all tests with temp output"
  echo "  $0 -o ./test-output       # Run tests with custom output directory"
  exit 0
}

while [[ $# -gt 0 ]]; do
  case $1 in
    -o|--output)
      OUTPUT_DIR="$2"
      shift 2
      ;;
    -h|--help)
      usage
      ;;
    *)
      err "Unknown option: $1"
      ;;
  esac
done

# Set output directory
if [ -z "$OUTPUT_DIR" ]; then
  OUTPUT_DIR=$(mktemp -d)
  msg "Using temp directory: ${OUTPUT_DIR}"
fi
mkdir -p "${OUTPUT_DIR}"

# ============================================================================
# TEST RESULT TRACKING
# ============================================================================

test_pass() {
  local name=$1
  TOTAL_TESTS=$((TOTAL_TESTS + 1))
  PASSED_TESTS=$((PASSED_TESTS + 1))
  printf "${COLOR_GREEN}[PASS]${COLOR_RESET} %s\n" "$name"
}

test_fail() {
  local name=$1
  local reason=$2
  TOTAL_TESTS=$((TOTAL_TESTS + 1))
  FAILED_TESTS=$((FAILED_TESTS + 1))
  printf "${COLOR_RED}[FAIL]${COLOR_RESET} %s: %s\n" "$name" "$reason"
}

# ============================================================================
# VERIFICATION HELPERS
# ============================================================================

# Verify umbrella chart structure (new architecture)
# The bundle command generates a Helm umbrella chart with:
#   - Chart.yaml (with dependencies)
#   - values.yaml (combined values for all components)
#   - README.md
#   - recipe.yaml (copy of the input recipe)
verify_umbrella_chart() {
  local bundle_dir=$1
  local test_name=$2
  
  # Check for required files
  local required_files=("Chart.yaml" "values.yaml" "README.md" "recipe.yaml")
  for file in "${required_files[@]}"; do
    if [ ! -f "${bundle_dir}/${file}" ]; then
      test_fail "$test_name" "Missing file: ${file}"
      return 1
    fi
  done
  
  # Verify Chart.yaml has dependencies
  if ! grep -q "dependencies:" "${bundle_dir}/Chart.yaml"; then
    test_fail "$test_name" "Chart.yaml missing dependencies section"
    return 1
  fi
  
  # Verify values.yaml has content
  if [ ! -s "${bundle_dir}/values.yaml" ]; then
    test_fail "$test_name" "values.yaml is empty"
    return 1
  fi
  
  test_pass "$test_name"
  return 0
}

# Verify a pattern exists in values.yaml
verify_pattern_in_values() {
  local values_file=$1
  local pattern=$2
  local test_name=$3
  
  if [ ! -f "$values_file" ]; then
    test_fail "$test_name" "values.yaml not found"
    return 1
  fi
  
  if ! grep -q "$pattern" "$values_file"; then
    test_fail "$test_name" "Pattern '${pattern}' not found in values.yaml"
    return 1
  fi
  
  test_pass "$test_name"
  return 0
}

# Verify ArgoCD App of Apps structure
# The --deployer argocd generates:
#   - app-of-apps.yaml (parent Application)
#   - README.md
#   - <component>/application.yaml (per-component)
#   - <component>/values.yaml (per-component)
verify_argocd_structure() {
  local bundle_dir=$1
  local test_name=$2
  
  # Check for required root files
  if [ ! -f "${bundle_dir}/app-of-apps.yaml" ]; then
    test_fail "$test_name" "Missing file: app-of-apps.yaml"
    return 1
  fi
  
  if [ ! -f "${bundle_dir}/README.md" ]; then
    test_fail "$test_name" "Missing file: README.md"
    return 1
  fi
  
  # Verify app-of-apps.yaml has ArgoCD Application kind
  if ! grep -q "kind: Application" "${bundle_dir}/app-of-apps.yaml"; then
    test_fail "$test_name" "app-of-apps.yaml missing 'kind: Application'"
    return 1
  fi
  
  # Check that at least one component directory exists with application.yaml
  local found_component=false
  for dir in "${bundle_dir}"/*/; do
    if [ -d "$dir" ] && [ -f "${dir}application.yaml" ]; then
      found_component=true
      # Verify component has values.yaml
      if [ ! -f "${dir}values.yaml" ]; then
        test_fail "$test_name" "Component directory missing values.yaml"
        return 1
      fi
      # Verify component application.yaml has sync-wave annotation
      if ! grep -q "argocd.argoproj.io/sync-wave" "${dir}application.yaml"; then
        test_fail "$test_name" "Component application.yaml missing sync-wave annotation"
        return 1
      fi
      break
    fi
  done
  
  if [ "$found_component" = false ]; then
    test_fail "$test_name" "No component directories with application.yaml found"
    return 1
  fi
  
  test_pass "$test_name"
  return 0
}

# ============================================================================
# BUILD
# ============================================================================

build_binary() {
  msg "=========================================="
  msg "Building cnsctl binary"
  msg "=========================================="
  
  cd "${ROOT}"
  
  if ! make build 2>&1; then
    err "Failed to build cnsctl binary"
  fi
  
  # Find the built binary (platform-specific)
  local os_name=$(uname -s | tr '[:upper:]' '[:lower:]')
  local arch_name=$(uname -m)
  
  # Convert arch name
  case "$arch_name" in
    x86_64) arch_name="amd64" ;;
    aarch64|arm64) arch_name="arm64" ;;
  esac
  
  # Try to find the binary with various naming patterns
  # goreleaser uses different suffixes:
  # - _v1 for amd64 (x86_64 microarchitecture level 1)
  # - _v8.0 for arm64 (ARMv8.0 baseline)
  CNSCTL_BIN=""
  for pattern in \
    "${ROOT}/dist/cnsctl_${os_name}_${arch_name}/cnsctl" \
    "${ROOT}/dist/cnsctl_${os_name}_${arch_name}_v1/cnsctl" \
    "${ROOT}/dist/cnsctl_${os_name}_${arch_name}_v8.0/cnsctl" \
    "${ROOT}/dist/cnsctl_${os_name}_all/cnsctl"; do
    if [ -x "$pattern" ]; then
      CNSCTL_BIN="$pattern"
      break
    fi
  done
  
  if [ -z "$CNSCTL_BIN" ] || [ ! -x "$CNSCTL_BIN" ]; then
    err "Built binary not found in dist/"
  fi
  
  test_pass "build/cnsctl-binary"
  msg "Using binary: ${CNSCTL_BIN}"
}

# ============================================================================
# RECIPE DATA FILE TESTS
# ============================================================================

# Test that leaf recipe data files can be used to generate recipes and bundles via CLI.
# This is a smoke test to verify the CLI workflow works end-to-end.
#
# Note: Detailed validation of YAML files (parsing, references, enums, constraints,
# inheritance chains) is covered by Go tests in pkg/recipe/yaml_test.go and
# pkg/recipe/metadata_test.go. This test only verifies CLI integration.
test_all_recipe_data_files() {
  msg ""
  msg "=========================================="
  msg "Testing CLI Workflow for Leaf Recipes"
  msg "=========================================="
  
  local recipe_data_dir="${ROOT}/pkg/recipe/data"
  local all_recipes_dir="${OUTPUT_DIR}/bundles/all-recipes"
  mkdir -p "$all_recipes_dir"
  
  # Find all overlay recipe files (exclude base.yaml)
  local recipe_files
  recipe_files=$(find "$recipe_data_dir" -maxdepth 1 -name "*.yaml" ! -name "base.yaml" -type f | sort)
  
  if [ -z "$recipe_files" ]; then
    test_fail "cli-workflow/find-files" "No recipe files found in ${recipe_data_dir}"
    return 1
  fi
  
  local leaf_count=0
  local skip_count=0
  
  for recipe_file in $recipe_files; do
    local basename
    basename=$(basename "$recipe_file" .yaml)
    
    # Extract criteria from the recipe metadata file
    local service accelerator os_val intent
    service=$(awk '/^  criteria:/{in_crit=1;next} in_crit && /^  [a-z]/{exit} in_crit && /service:/{gsub(/.*service: /,""); print}' "$recipe_file")
    accelerator=$(awk '/^  criteria:/{in_crit=1;next} in_crit && /^  [a-z]/{exit} in_crit && /accelerator:/{gsub(/.*accelerator: /,""); print}' "$recipe_file")
    os_val=$(awk '/^  criteria:/{in_crit=1;next} in_crit && /^  [a-z]/{exit} in_crit && /os:/{gsub(/.*os: /,""); print}' "$recipe_file")
    intent=$(awk '/^  criteria:/{in_crit=1;next} in_crit && /^  [a-z]/{exit} in_crit && /intent:/{gsub(/.*intent: /,""); print}' "$recipe_file")
    
    # Skip intermediate recipes (those without complete criteria)
    # Go tests validate intermediate recipes; here we only test CLI with leaf recipes
    if [ -z "$accelerator" ] || [ -z "$os_val" ] || [ -z "$intent" ]; then
      skip_count=$((skip_count + 1))
      continue
    fi
    
    leaf_count=$((leaf_count + 1))
    local test_dir="${all_recipes_dir}/${basename}"
    mkdir -p "$test_dir"
    
    # Build CLI command
    local recipe_result="${test_dir}/recipe.yaml"
    local recipe_cmd="${CNSCTL_BIN} recipe --accelerator $accelerator --os $os_val --intent $intent"
    if [ -n "$service" ]; then
      recipe_cmd="$recipe_cmd --service $service"
    fi
    recipe_cmd="$recipe_cmd -o $recipe_result"
    
    # Test: CLI generates recipe
    if ! eval "$recipe_cmd" 2>&1; then
      test_fail "cli-workflow/${basename}/recipe" "Failed to generate recipe"
      continue
    fi
    
    # Test: CLI generates bundle
    local bundle_dir="${test_dir}/bundles"
    if ! "${CNSCTL_BIN}" bundle -r "$recipe_result" -o "$bundle_dir" 2>&1; then
      test_fail "cli-workflow/${basename}/bundle" "Failed to generate bundle"
      continue
    fi
    
    # Test: Verify umbrella chart structure
    if ! verify_umbrella_chart "$bundle_dir" "cli-workflow/${basename}/umbrella-chart"; then
      continue
    fi
    
    # Count dependencies in Chart.yaml (indicates number of components)
    local dep_count
    dep_count=$(grep -c "^  - name:" "${bundle_dir}/Chart.yaml" 2>/dev/null || echo "0")
    
    test_pass "cli-workflow/${basename} (${dep_count} dependencies)"
  done
  
  msg ""
  msg "Tested ${leaf_count} leaf recipes (skipped ${skip_count} intermediate recipes)"
}

# ============================================================================
# RECIPE GENERATION (Query Mode)
# ============================================================================

RECIPE_FILE=""

generate_recipe() {
  msg ""
  msg "=========================================="
  msg "Generating Recipe (Query Mode)"
  msg "=========================================="
  msg "Parameters: service=eks, accelerator=gb200, os=ubuntu, intent=training"
  
  RECIPE_FILE="${OUTPUT_DIR}/recipe.yaml"
  
  if ! "${CNSCTL_BIN}" recipe \
    --service eks \
    --accelerator gb200 \
    --os ubuntu \
    --intent training \
    --output "${RECIPE_FILE}" 2>&1; then
    test_fail "recipe/generation" "Failed to generate recipe"
    return 1
  fi
  
  # Verify recipe file was created
  if [ ! -f "$RECIPE_FILE" ]; then
    test_fail "recipe/file-exists" "Recipe file was not created"
    return 1
  fi
  test_pass "recipe/file-exists"
  
  # Verify recipe contains expected kind (note: kind is lowercase in output)
  if ! grep -q "kind: recipeResult" "$RECIPE_FILE"; then
    test_fail "recipe/valid-format" "Recipe does not contain 'kind: recipeResult'"
    return 1
  fi
  test_pass "recipe/valid-format"
  
  # Verify recipe contains gpu-operator component
  if ! grep -q "gpu-operator" "$RECIPE_FILE"; then
    test_fail "recipe/has-gpu-operator" "Recipe does not contain gpu-operator component"
    return 1
  fi
  test_pass "recipe/has-gpu-operator"
  
  # Verify recipe contains skyhook-operator component
  if ! grep -q "skyhook-operator" "$RECIPE_FILE"; then
    test_fail "recipe/has-skyhook-operator" "Recipe does not contain skyhook-operator component"
    return 1
  fi
  test_pass "recipe/has-skyhook-operator"
  
  msg "Recipe saved to: ${RECIPE_FILE}"
}

# ============================================================================
# BUNDLE TESTS
# ============================================================================

run_bundle_tests() {
  local recipe_file=$1
  
  msg ""
  msg "=========================================="
  msg "Running Bundle Generation Tests"
  msg "=========================================="
  
  # -------------------------------------------------------------------------
  # Test 1: Basic bundle generation (no overrides)
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 1: Basic Bundle Generation (No Overrides) ---"
  
  local basic_dir="${OUTPUT_DIR}/bundles/basic"
  mkdir -p "$basic_dir"
  
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$basic_dir" 2>&1; then
    test_fail "bundle/basic/generation" "Bundle generation failed"
  else
    test_pass "bundle/basic/generation"
    
    # Verify umbrella chart structure
    verify_umbrella_chart "$basic_dir" "bundle/basic/umbrella-chart"
    
    # Verify expected components in Chart.yaml dependencies
    verify_pattern_in_values "${basic_dir}/Chart.yaml" \
      "gpu-operator" "bundle/basic/has-gpu-operator-dep"
    verify_pattern_in_values "${basic_dir}/Chart.yaml" \
      "skyhook-operator" "bundle/basic/has-skyhook-operator-dep"
  fi
  
  # -------------------------------------------------------------------------
  # Test 2: With system node selector
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 2: With System Node Selector ---"
  
  local sys_selector_dir="${OUTPUT_DIR}/bundles/system-selector"
  mkdir -p "$sys_selector_dir"
  
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$sys_selector_dir" \
    --system-node-selector nodeGroup=system-pool \
    --system-node-selector workload=control-plane 2>&1; then
    test_fail "bundle/system-selector/generation" "Bundle generation failed"
  else
    test_pass "bundle/system-selector/generation"
    
    # Verify node selector in combined values.yaml
    verify_pattern_in_values "${sys_selector_dir}/values.yaml" \
      "nodeGroup" "bundle/system-selector/has-nodeGroup"
    verify_pattern_in_values "${sys_selector_dir}/values.yaml" \
      "system-pool" "bundle/system-selector/has-system-pool"
  fi
  
  # -------------------------------------------------------------------------
  # Test 3: With accelerated node selector
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 3: With Accelerated Node Selector ---"
  
  local accel_selector_dir="${OUTPUT_DIR}/bundles/accel-selector"
  mkdir -p "$accel_selector_dir"
  
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$accel_selector_dir" \
    --accelerated-node-selector accelerator=nvidia-gpu \
    --accelerated-node-selector gpu-type=gb200 2>&1; then
    test_fail "bundle/accel-selector/generation" "Bundle generation failed"
  else
    test_pass "bundle/accel-selector/generation"
    
    # Verify accelerated node selector in combined values.yaml
    verify_pattern_in_values "${accel_selector_dir}/values.yaml" \
      "accelerator" "bundle/accel-selector/has-accelerator"
    verify_pattern_in_values "${accel_selector_dir}/values.yaml" \
      "nvidia-gpu" "bundle/accel-selector/has-nvidia-gpu"
  fi
  
  # -------------------------------------------------------------------------
  # Test 4: With system node tolerations
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 4: With System Node Tolerations ---"
  
  local sys_toleration_dir="${OUTPUT_DIR}/bundles/system-toleration"
  mkdir -p "$sys_toleration_dir"
  
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$sys_toleration_dir" \
    --system-node-toleration dedicated=system-workload:NoSchedule 2>&1; then
    test_fail "bundle/system-toleration/generation" "Bundle generation failed"
  else
    test_pass "bundle/system-toleration/generation"
    
    # Verify system toleration in combined values.yaml
    verify_pattern_in_values "${sys_toleration_dir}/values.yaml" \
      "dedicated" "bundle/system-toleration/has-dedicated"
    verify_pattern_in_values "${sys_toleration_dir}/values.yaml" \
      "system-workload" "bundle/system-toleration/has-system-workload"
  fi
  
  # -------------------------------------------------------------------------
  # Test 5: With accelerated node tolerations
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 5: With Accelerated Node Tolerations ---"
  
  local accel_toleration_dir="${OUTPUT_DIR}/bundles/accel-toleration"
  mkdir -p "$accel_toleration_dir"
  
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$accel_toleration_dir" \
    --accelerated-node-toleration nvidia.com/gpu=present:NoSchedule 2>&1; then
    test_fail "bundle/accel-toleration/generation" "Bundle generation failed"
  else
    test_pass "bundle/accel-toleration/generation"
    
    # Verify accelerated toleration in combined values.yaml
    verify_pattern_in_values "${accel_toleration_dir}/values.yaml" \
      "nvidia.com/gpu" "bundle/accel-toleration/has-nvidia-gpu"
  fi
  
  # -------------------------------------------------------------------------
  # Test 6: With value overrides (--set)
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 6: With Value Overrides (--set) ---"
  
  local override_dir="${OUTPUT_DIR}/bundles/value-override"
  mkdir -p "$override_dir"
  
  # Test value overrides for gpu-operator (under gpuoperator: key in values.yaml)
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$override_dir" \
    --set gpu-operator:driver.version=999.99.99 \
    --set gpu-operator:cdi.enabled=true 2>&1; then
    test_fail "bundle/value-override/generation" "Bundle generation failed"
  else
    test_pass "bundle/value-override/generation"
    
    # Verify value overrides in combined values.yaml
    verify_pattern_in_values "${override_dir}/values.yaml" \
      "999.99.99" "bundle/value-override/driver-version"
  fi
  
  # -------------------------------------------------------------------------
  # Test 7: Combined overrides (all flags together)
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 7: Combined Overrides (All Flags) ---"
  
  local combined_dir="${OUTPUT_DIR}/bundles/combined"
  mkdir -p "$combined_dir"
  
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$combined_dir" \
    --system-node-selector nodeGroup=system-pool \
    --system-node-toleration dedicated=system:NoSchedule \
    --accelerated-node-selector accelerator=nvidia-gpu \
    --accelerated-node-toleration nvidia.com/gpu=present:NoSchedule \
    --set gpu-operator:driver.version=888.88.88 2>&1; then
    test_fail "bundle/combined/generation" "Bundle generation failed"
  else
    test_pass "bundle/combined/generation"
    
    # Verify umbrella chart structure
    verify_umbrella_chart "$combined_dir" "bundle/combined/umbrella-chart"
    
    # Verify system node selector
    verify_pattern_in_values "${combined_dir}/values.yaml" \
      "nodeGroup" "bundle/combined/system-selector"
    
    # Verify system toleration
    verify_pattern_in_values "${combined_dir}/values.yaml" \
      "dedicated" "bundle/combined/system-toleration"
    
    # Verify accelerated node selector
    verify_pattern_in_values "${combined_dir}/values.yaml" \
      "accelerator" "bundle/combined/accel-selector"
    
    # Verify accelerated toleration
    verify_pattern_in_values "${combined_dir}/values.yaml" \
      "nvidia.com/gpu" "bundle/combined/accel-toleration"
    
    # Verify value override
    verify_pattern_in_values "${combined_dir}/values.yaml" \
      "888.88.88" "bundle/combined/value-override"
  fi
  
  # -------------------------------------------------------------------------
  # Test 8: ArgoCD Deployer
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 8: ArgoCD Deployer (--deployer argocd) ---"
  
  local argocd_dir="${OUTPUT_DIR}/bundles/argocd"
  mkdir -p "$argocd_dir"
  
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$argocd_dir" \
    --deployer argocd 2>&1; then
    test_fail "bundle/argocd/generation" "Bundle generation with --deployer argocd failed"
  else
    test_pass "bundle/argocd/generation"
    
    # Verify ArgoCD App of Apps structure
    verify_argocd_structure "$argocd_dir" "bundle/argocd/structure"
  fi
}

# ============================================================================
# MAIN
# ============================================================================

msg "Starting E2E Integration Tests"
msg "Output directory: ${OUTPUT_DIR}"
msg ""

# Step 1: Build the binary
build_binary

# Step 2: Test CLI workflow for all leaf recipes in pkg/recipe/data/
# Note: YAML file validation (parsing, references, inheritance chains) is covered
# by Go tests in pkg/recipe/yaml_test.go and pkg/recipe/metadata_test.go
test_all_recipe_data_files

# Step 3: Generate recipe via query mode (for detailed bundle flag tests)
generate_recipe

# Step 4: Run bundle tests with various CLI flags (using generated recipe)
if [ -n "$RECIPE_FILE" ] && [ -f "$RECIPE_FILE" ]; then
  run_bundle_tests "$RECIPE_FILE"
else
  err "Recipe file not found, cannot run bundle tests"
fi

# Print summary
echo ""
msg "=========================================="
msg "Test Summary"
msg "=========================================="
echo "Total:  ${TOTAL_TESTS}"
echo "Passed: ${PASSED_TESTS}"
echo "Failed: ${FAILED_TESTS}"
echo ""
msg "Output directory: ${OUTPUT_DIR}"

if [ "$FAILED_TESTS" -gt 0 ]; then
  err "Some tests failed!"
fi

msg "All tests passed!"