#!/bin/bash
set -eo pipefail

# Dir setup
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
. "${DIR}/common"
ROOT=$(dirname "${DIR}")

# Check required tools
has_tools awk find grep make sed uname

# Default values
OUTPUT_DIR=""
CNSCTL_BIN=""

# Test configuration
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

# Parse flags
usage() {
  echo "Usage: $0 [OPTIONS]"
  echo ""
  echo "Options:"
  echo "  -o, --output PATH     Output directory for test artifacts (default: temp dir)"
  echo "  -h, --help            Show this help message"
  echo ""
  echo "This script:"
  echo "  1. Builds the cnsctl binary using 'make build'"
  echo "  2. Tests all recipe metadata files in pkg/recipe/data/ can generate bundles"
  echo "  3. Generates a recipe via query mode (service=eks, accelerator=gb200, os=ubuntu, intent=training)"
  echo "  4. Tests bundle generation with various CLI flag combinations:"
  echo "     - Basic generation (no overrides)"
  echo "     - System node selectors (--system-node-selector)"
  echo "     - Accelerated node selectors (--accelerated-node-selector)"
  echo "     - System tolerations (--system-node-toleration)"
  echo "     - Accelerated tolerations (--accelerated-node-toleration)"
  echo "     - Value overrides (--set)"
  echo "     - Combined flags"
  echo ""
  echo "Examples:"
  echo "  $0                        # Run all tests with temp output"
  echo "  $0 -o ./test-output       # Run tests with custom output directory"
  exit 0
}

while [[ $# -gt 0 ]]; do
  case $1 in
    -o|--output)
      OUTPUT_DIR="$2"
      shift 2
      ;;
    -h|--help)
      usage
      ;;
    *)
      err "Unknown option: $1"
      ;;
  esac
done

# Set output directory
if [ -z "$OUTPUT_DIR" ]; then
  OUTPUT_DIR=$(mktemp -d)
  msg "Using temp directory: ${OUTPUT_DIR}"
fi
mkdir -p "${OUTPUT_DIR}"

# ============================================================================
# TEST RESULT TRACKING
# ============================================================================

test_pass() {
  local name=$1
  TOTAL_TESTS=$((TOTAL_TESTS + 1))
  PASSED_TESTS=$((PASSED_TESTS + 1))
  printf "${COLOR_GREEN}[PASS]${COLOR_RESET} %s\n" "$name"
}

test_fail() {
  local name=$1
  local reason=$2
  TOTAL_TESTS=$((TOTAL_TESTS + 1))
  FAILED_TESTS=$((FAILED_TESTS + 1))
  printf "${COLOR_RED}[FAIL]${COLOR_RESET} %s: %s\n" "$name" "$reason"
}

# ============================================================================
# VERIFICATION HELPERS
# ============================================================================

# Verify values.yaml contains expected content
verify_values_yaml() {
  local values_file=$1
  local test_name=$2
  
  if [ ! -f "$values_file" ]; then
    test_fail "$test_name" "values.yaml not found"
    return 1
  fi
  
  # Check for metadata header
  if ! grep -q "Generated from Cloud Native Stack Recipe" "$values_file"; then
    test_fail "$test_name" "Missing metadata header in values.yaml"
    return 1
  fi
  
  return 0
}

# Verify bundle structure for a component
verify_bundle() {
  local bundle_dir=$1
  local component=$2
  local test_name=$3
  
  local component_dir="${bundle_dir}/${component}"
  
  if [ ! -d "$component_dir" ]; then
    test_fail "$test_name" "Component directory not found: ${component}"
    return 1
  fi
  
  # Check for required files
  local required_files=("values.yaml" "checksums.txt" "README.md")
  for file in "${required_files[@]}"; do
    if [ ! -f "${component_dir}/${file}" ]; then
      test_fail "$test_name" "Missing file: ${component}/${file}"
      return 1
    fi
  done
  
  # Verify values.yaml content
  if ! verify_values_yaml "${component_dir}/values.yaml" "$test_name"; then
    return 1
  fi
  
  test_pass "$test_name"
  return 0
}

# Verify a pattern exists in values.yaml
verify_pattern_in_values() {
  local values_file=$1
  local pattern=$2
  local test_name=$3
  
  if [ ! -f "$values_file" ]; then
    test_fail "$test_name" "values.yaml not found"
    return 1
  fi
  
  if ! grep -q "$pattern" "$values_file"; then
    test_fail "$test_name" "Pattern '${pattern}' not found in values.yaml"
    return 1
  fi
  
  test_pass "$test_name"
  return 0
}

# ============================================================================
# BUILD
# ============================================================================

build_binary() {
  msg "=========================================="
  msg "Building cnsctl binary"
  msg "=========================================="
  
  cd "${ROOT}"
  
  if ! make build 2>&1; then
    err "Failed to build cnsctl binary"
  fi
  
  # Find the built binary (platform-specific)
  local os_name=$(uname -s | tr '[:upper:]' '[:lower:]')
  local arch_name=$(uname -m)
  
  # Convert arch name
  case "$arch_name" in
    x86_64) arch_name="amd64" ;;
    aarch64|arm64) arch_name="arm64" ;;
  esac
  
  # Try to find the binary with various naming patterns
  # goreleaser uses different suffixes:
  # - _v1 for amd64 (x86_64 microarchitecture level 1)
  # - _v8.0 for arm64 (ARMv8.0 baseline)
  CNSCTL_BIN=""
  for pattern in \
    "${ROOT}/dist/cnsctl_${os_name}_${arch_name}/cnsctl" \
    "${ROOT}/dist/cnsctl_${os_name}_${arch_name}_v1/cnsctl" \
    "${ROOT}/dist/cnsctl_${os_name}_${arch_name}_v8.0/cnsctl" \
    "${ROOT}/dist/cnsctl_${os_name}_all/cnsctl"; do
    if [ -x "$pattern" ]; then
      CNSCTL_BIN="$pattern"
      break
    fi
  done
  
  if [ -z "$CNSCTL_BIN" ] || [ ! -x "$CNSCTL_BIN" ]; then
    err "Built binary not found in dist/"
  fi
  
  test_pass "build/cnsctl-binary"
  msg "Using binary: ${CNSCTL_BIN}"
}

# ============================================================================
# RECIPE DATA FILE TESTS
# ============================================================================

# Test all recipe metadata files in pkg/recipe/data/ can be used to generate recipes and bundles
# The workflow is: metadata file -> cnsctl recipe -> RecipeResult -> cnsctl bundle
test_all_recipe_data_files() {
  msg ""
  msg "=========================================="
  msg "Testing All Recipe Data Files"
  msg "=========================================="
  
  local recipe_data_dir="${ROOT}/pkg/recipe/data"
  local all_recipes_dir="${OUTPUT_DIR}/bundles/all-recipes"
  mkdir -p "$all_recipes_dir"
  
  # Find all overlay recipe files (exclude base.yaml and README.md)
  local recipe_files
  recipe_files=$(find "$recipe_data_dir" -maxdepth 1 -name "*.yaml" ! -name "base.yaml" -type f | sort)
  
  if [ -z "$recipe_files" ]; then
    test_fail "recipe-data/find-files" "No recipe files found in ${recipe_data_dir}"
    return 1
  fi
  test_pass "recipe-data/find-files"
  
  local file_count=0
  for recipe_file in $recipe_files; do
    local basename
    basename=$(basename "$recipe_file" .yaml)
    file_count=$((file_count + 1))
    
    msg ""
    msg "--- Testing recipe: ${basename} ---"
    
    local test_dir="${all_recipes_dir}/${basename}"
    mkdir -p "$test_dir"
    
    # Extract criteria from the recipe metadata file to use with cnsctl recipe
    # Parse service, accelerator, os, intent from criteria section
    local service accelerator os_val intent
    service=$(awk '/^  criteria:/{in_crit=1;next} in_crit && /^  [a-z]/{exit} in_crit && /service:/{gsub(/.*service: /,""); print}' "$recipe_file")
    accelerator=$(awk '/^  criteria:/{in_crit=1;next} in_crit && /^  [a-z]/{exit} in_crit && /accelerator:/{gsub(/.*accelerator: /,""); print}' "$recipe_file")
    os_val=$(awk '/^  criteria:/{in_crit=1;next} in_crit && /^  [a-z]/{exit} in_crit && /os:/{gsub(/.*os: /,""); print}' "$recipe_file")
    intent=$(awk '/^  criteria:/{in_crit=1;next} in_crit && /^  [a-z]/{exit} in_crit && /intent:/{gsub(/.*intent: /,""); print}' "$recipe_file")
    
    # At minimum we need accelerator, os, and intent
    if [ -z "$accelerator" ] || [ -z "$os_val" ] || [ -z "$intent" ]; then
      test_fail "recipe-data/${basename}/parse-criteria" "Could not extract required criteria from ${basename} (need accelerator, os, intent)"
      continue
    fi
    
    # Build criteria summary for logging
    local criteria_summary="accelerator=${accelerator}, os=${os_val}, intent=${intent}"
    if [ -n "$service" ]; then
      criteria_summary="service=${service}, ${criteria_summary}"
    fi
    test_pass "recipe-data/${basename}/parse-criteria (${criteria_summary})"
    
    # Step 1: Generate RecipeResult using cnsctl recipe with the extracted criteria
    # Build the command with optional service flag
    local recipe_result="${test_dir}/recipe.yaml"
    local recipe_cmd="${CNSCTL_BIN} recipe --accelerator $accelerator --os $os_val --intent $intent"
    if [ -n "$service" ]; then
      recipe_cmd="$recipe_cmd --service $service"
    fi
    recipe_cmd="$recipe_cmd -o $recipe_result"
    
    if ! eval "$recipe_cmd" 2>&1; then
      test_fail "recipe-data/${basename}/recipe-generation" "Failed to generate recipe from criteria"
      continue
    fi
    test_pass "recipe-data/${basename}/recipe-generation"
    
    # Verify recipe file was created
    if [ ! -f "$recipe_result" ]; then
      test_fail "recipe-data/${basename}/recipe-file-exists" "Recipe file not created"
      continue
    fi
    test_pass "recipe-data/${basename}/recipe-file-exists"
    
    # Step 2: Generate bundle from RecipeResult
    local bundle_dir="${test_dir}/bundles"
    if ! "${CNSCTL_BIN}" bundle -f "$recipe_result" -o "$bundle_dir" 2>&1; then
      test_fail "recipe-data/${basename}/bundle-generation" "Failed to generate bundle from recipe"
      continue
    fi
    test_pass "recipe-data/${basename}/bundle-generation"
    
    # Verify at least one component was generated
    local component_count
    component_count=$(find "$bundle_dir" -mindepth 1 -maxdepth 1 -type d | wc -l | tr -d ' ')
    
    if [ "$component_count" -eq 0 ]; then
      test_fail "recipe-data/${basename}/has-components" "No components generated for ${basename}"
      continue
    fi
    test_pass "recipe-data/${basename}/has-components (${component_count} components)"
    
    # Verify each generated component has required files
    for component_dir in "${bundle_dir}"/*/; do
      if [ -d "$component_dir" ]; then
        local component_name
        component_name=$(basename "$component_dir")
        
        # Check for values.yaml
        if [ ! -f "${component_dir}values.yaml" ]; then
          test_fail "recipe-data/${basename}/${component_name}/values.yaml" "Missing values.yaml"
        else
          test_pass "recipe-data/${basename}/${component_name}/values.yaml"
        fi
        
        # Check for checksums.txt
        if [ ! -f "${component_dir}checksums.txt" ]; then
          test_fail "recipe-data/${basename}/${component_name}/checksums.txt" "Missing checksums.txt"
        else
          test_pass "recipe-data/${basename}/${component_name}/checksums.txt"
        fi
      fi
    done
  done
  
  msg ""
  msg "Tested ${file_count} recipe data files"
}

# ============================================================================
# RECIPE GENERATION (Query Mode)
# ============================================================================

RECIPE_FILE=""

generate_recipe() {
  msg ""
  msg "=========================================="
  msg "Generating Recipe (Query Mode)"
  msg "=========================================="
  msg "Parameters: service=eks, accelerator=gb200, os=ubuntu, intent=training"
  
  RECIPE_FILE="${OUTPUT_DIR}/recipe.yaml"
  
  if ! "${CNSCTL_BIN}" recipe \
    --service eks \
    --accelerator gb200 \
    --os ubuntu \
    --intent training \
    --output "${RECIPE_FILE}" 2>&1; then
    test_fail "recipe/generation" "Failed to generate recipe"
    return 1
  fi
  
  # Verify recipe file was created
  if [ ! -f "$RECIPE_FILE" ]; then
    test_fail "recipe/file-exists" "Recipe file was not created"
    return 1
  fi
  test_pass "recipe/file-exists"
  
  # Verify recipe contains expected kind (note: kind is lowercase in output)
  if ! grep -q "kind: recipeResult" "$RECIPE_FILE"; then
    test_fail "recipe/valid-format" "Recipe does not contain 'kind: recipeResult'"
    return 1
  fi
  test_pass "recipe/valid-format"
  
  # Verify recipe contains gpu-operator component
  if ! grep -q "gpu-operator" "$RECIPE_FILE"; then
    test_fail "recipe/has-gpu-operator" "Recipe does not contain gpu-operator component"
    return 1
  fi
  test_pass "recipe/has-gpu-operator"
  
  # Verify recipe contains skyhook component
  if ! grep -q "skyhook" "$RECIPE_FILE"; then
    test_fail "recipe/has-skyhook" "Recipe does not contain skyhook component"
    return 1
  fi
  test_pass "recipe/has-skyhook"
  
  msg "Recipe saved to: ${RECIPE_FILE}"
}

# ============================================================================
# BUNDLE TESTS
# ============================================================================

run_bundle_tests() {
  local recipe_file=$1
  
  msg ""
  msg "=========================================="
  msg "Running Bundle Generation Tests"
  msg "=========================================="
  
  # -------------------------------------------------------------------------
  # Test 1: Basic bundle generation (no overrides)
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 1: Basic Bundle Generation (No Overrides) ---"
  
  local basic_dir="${OUTPUT_DIR}/bundles/basic"
  mkdir -p "$basic_dir"
  
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$basic_dir" 2>&1; then
    test_fail "bundle/basic/generation" "Bundle generation failed"
  else
    test_pass "bundle/basic/generation"
    
    # Verify expected components
    verify_bundle "$basic_dir" "gpu-operator" "bundle/basic/gpu-operator"
    verify_bundle "$basic_dir" "skyhook" "bundle/basic/skyhook"
  fi
  
  # -------------------------------------------------------------------------
  # Test 2: With system node selector
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 2: With System Node Selector ---"
  
  local sys_selector_dir="${OUTPUT_DIR}/bundles/system-selector"
  mkdir -p "$sys_selector_dir"
  
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$sys_selector_dir" \
    --system-node-selector nodeGroup=system-pool \
    --system-node-selector workload=control-plane 2>&1; then
    test_fail "bundle/system-selector/generation" "Bundle generation failed"
  else
    test_pass "bundle/system-selector/generation"
    
    # Verify node selector in gpu-operator (operator.nodeSelector)
    verify_pattern_in_values "${sys_selector_dir}/gpu-operator/values.yaml" \
      "nodeGroup" "bundle/system-selector/gpu-operator-has-nodeGroup"
    verify_pattern_in_values "${sys_selector_dir}/gpu-operator/values.yaml" \
      "system-pool" "bundle/system-selector/gpu-operator-has-system-pool"
  fi
  
  # -------------------------------------------------------------------------
  # Test 3: With accelerated node selector
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 3: With Accelerated Node Selector ---"
  
  local accel_selector_dir="${OUTPUT_DIR}/bundles/accel-selector"
  mkdir -p "$accel_selector_dir"
  
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$accel_selector_dir" \
    --accelerated-node-selector accelerator=nvidia-gpu \
    --accelerated-node-selector gpu-type=gb200 2>&1; then
    test_fail "bundle/accel-selector/generation" "Bundle generation failed"
  else
    test_pass "bundle/accel-selector/generation"
    
    # Verify accelerated node selector in skyhook
    verify_pattern_in_values "${accel_selector_dir}/skyhook/values.yaml" \
      "accelerator" "bundle/accel-selector/skyhook-has-accelerator"
    verify_pattern_in_values "${accel_selector_dir}/skyhook/values.yaml" \
      "nvidia-gpu" "bundle/accel-selector/skyhook-has-nvidia-gpu"
  fi
  
  # -------------------------------------------------------------------------
  # Test 4: With system node tolerations
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 4: With System Node Tolerations ---"
  
  local sys_toleration_dir="${OUTPUT_DIR}/bundles/system-toleration"
  mkdir -p "$sys_toleration_dir"
  
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$sys_toleration_dir" \
    --system-node-toleration dedicated=system-workload:NoSchedule 2>&1; then
    test_fail "bundle/system-toleration/generation" "Bundle generation failed"
  else
    test_pass "bundle/system-toleration/generation"
    
    # Verify system toleration in gpu-operator (operator.tolerations)
    verify_pattern_in_values "${sys_toleration_dir}/gpu-operator/values.yaml" \
      "dedicated" "bundle/system-toleration/gpu-operator-has-dedicated"
    verify_pattern_in_values "${sys_toleration_dir}/gpu-operator/values.yaml" \
      "system-workload" "bundle/system-toleration/gpu-operator-has-system-workload"
  fi
  
  # -------------------------------------------------------------------------
  # Test 5: With accelerated node tolerations
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 5: With Accelerated Node Tolerations ---"
  
  local accel_toleration_dir="${OUTPUT_DIR}/bundles/accel-toleration"
  mkdir -p "$accel_toleration_dir"
  
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$accel_toleration_dir" \
    --accelerated-node-toleration nvidia.com/gpu=present:NoSchedule 2>&1; then
    test_fail "bundle/accel-toleration/generation" "Bundle generation failed"
  else
    test_pass "bundle/accel-toleration/generation"
    
    # Verify accelerated toleration in gpu-operator (daemonsets.tolerations)
    verify_pattern_in_values "${accel_toleration_dir}/gpu-operator/values.yaml" \
      "nvidia.com/gpu" "bundle/accel-toleration/gpu-operator-has-nvidia-gpu"
    
    # Verify accelerated toleration in skyhook
    verify_pattern_in_values "${accel_toleration_dir}/skyhook/values.yaml" \
      "nvidia.com/gpu" "bundle/accel-toleration/skyhook-has-nvidia-gpu"
  fi
  
  # -------------------------------------------------------------------------
  # Test 6: With value overrides (--set)
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 6: With Value Overrides (--set) ---"
  
  local override_dir="${OUTPUT_DIR}/bundles/value-override"
  mkdir -p "$override_dir"
  
  # Note: Only test gpu-operator overrides. Skyhook validates customization names
  # and only accepts 'ubuntu' as a valid customization, not arbitrary test values.
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$override_dir" \
    --set gpu-operator:driver.version=999.99.99 \
    --set gpu-operator:cdi.enabled=true \
    --set cert-manager:installCRDs=true 2>&1; then
    test_fail "bundle/value-override/generation" "Bundle generation failed"
  else
    test_pass "bundle/value-override/generation"
    
    # Verify value overrides
    verify_pattern_in_values "${override_dir}/gpu-operator/values.yaml" \
      "999.99.99" "bundle/value-override/gpu-operator-driver-version"
    verify_pattern_in_values "${override_dir}/cert-manager/values.yaml" \
      "installCRDs" "bundle/value-override/cert-manager-installCRDs"
  fi
  
  # -------------------------------------------------------------------------
  # Test 7: Combined overrides (all flags together)
  # -------------------------------------------------------------------------
  msg ""
  msg "--- Test 7: Combined Overrides (All Flags) ---"
  
  local combined_dir="${OUTPUT_DIR}/bundles/combined"
  mkdir -p "$combined_dir"
  
  if ! "${CNSCTL_BIN}" bundle -r "$recipe_file" -o "$combined_dir" \
    --system-node-selector nodeGroup=system-pool \
    --system-node-toleration dedicated=system:NoSchedule \
    --accelerated-node-selector accelerator=nvidia-gpu \
    --accelerated-node-toleration nvidia.com/gpu=present:NoSchedule \
    --set gpu-operator:driver.version=888.88.88 2>&1; then
    test_fail "bundle/combined/generation" "Bundle generation failed"
  else
    test_pass "bundle/combined/generation"
    
    # Verify all components exist
    verify_bundle "$combined_dir" "gpu-operator" "bundle/combined/gpu-operator"
    verify_bundle "$combined_dir" "skyhook" "bundle/combined/skyhook"
    
    # Verify system node selector
    verify_pattern_in_values "${combined_dir}/gpu-operator/values.yaml" \
      "nodeGroup" "bundle/combined/system-selector"
    
    # Verify system toleration
    verify_pattern_in_values "${combined_dir}/gpu-operator/values.yaml" \
      "dedicated" "bundle/combined/system-toleration"
    
    # Verify accelerated node selector in skyhook
    verify_pattern_in_values "${combined_dir}/skyhook/values.yaml" \
      "accelerator" "bundle/combined/accel-selector"
    
    # Verify accelerated toleration in both
    verify_pattern_in_values "${combined_dir}/gpu-operator/values.yaml" \
      "nvidia.com/gpu" "bundle/combined/gpu-operator-accel-toleration"
    verify_pattern_in_values "${combined_dir}/skyhook/values.yaml" \
      "nvidia.com/gpu" "bundle/combined/skyhook-accel-toleration"
    
    # Verify value override
    verify_pattern_in_values "${combined_dir}/gpu-operator/values.yaml" \
      "888.88.88" "bundle/combined/value-override"
  fi
}

# ============================================================================
# MAIN
# ============================================================================

msg "Starting E2E Integration Tests"
msg "Output directory: ${OUTPUT_DIR}"
msg ""

# Step 1: Build the binary
build_binary

# Step 2: Test all recipe data files in pkg/recipe/data/
test_all_recipe_data_files

# Step 3: Generate recipe via query mode (for detailed bundle flag tests)
generate_recipe

# Step 4: Run bundle tests with various CLI flags (using generated recipe)
if [ -n "$RECIPE_FILE" ] && [ -f "$RECIPE_FILE" ]; then
  run_bundle_tests "$RECIPE_FILE"
else
  err "Recipe file not found, cannot run bundle tests"
fi

# Print summary
echo ""
msg "=========================================="
msg "Test Summary"
msg "=========================================="
echo "Total:  ${TOTAL_TESTS}"
echo "Passed: ${PASSED_TESTS}"
echo "Failed: ${FAILED_TESTS}"
echo ""
msg "Output directory: ${OUTPUT_DIR}"

if [ "$FAILED_TESTS" -gt 0 ]; then
  err "Some tests failed!"
fi

msg "All tests passed!"